\chapter{Tree Sitter}

\textbf{Tree Sitter} e' un parser generator molto efficiente quando si tratta di rianalizzare un file che ha subito delle modifiche. Infatti e' in grado generare in maniera incrementale l'albero risultante contanto solo delle modifiche subite dal file in questione.

Oltre a questo evidente vantaggio a differenza dei suoi concorrenti principali possiede anche dei language binding molto convenienti.

\section{In Rust}

Per utilizzare \textbf{tree sitter} in \textbf{rust} prima di tutto e' necessario importare le necessarie dipendenze. Nel file Cargo.toml:

\begin{verbatim}
  [dependencies]
  tree-sitter = "*"
  tree-sitter-java = "*"
\end{verbatim}

Se si vuole utilizzare il parser tree sitter per il java per esempio si inserisca tra le dipendenze \textbf{tree-sitter-java}. In generale per un linguaggio $x$ e' necessario importare ed utilizzare la libreria $tree-sitter-x$. La lista dei linguaggi supportati e' disponibile sul sito del progetto Tree Sitter.

Quindi per utilizzare il parser del linguaggio $java$ si usa il seguente snippet:

\begin{verbatim}
  let mut the_parser = tree_sitter::Parser::new();
  let the_language = tree_sitter_java::language();
  the_parser.set_language(the_language);
  let tree = the_parser.parse(the_text);
\end{verbatim}

La variabile \textbf{tree : tree\_sitter::Tree} conterra' l'albero generato da tree sitter.

\textbf{TODO: spiega come generare il tree con il diff}

\section{DSL}

Tree Sitter definisce un Domain Specific Language per ogni linguaggio di programmazione che supporta. Nel caso del programma java:

\begin{verbatim}
// https://www.programiz.com/java-programming/inheritance
package unimib.ingsof;

class Animal {

  // field and method of the parent class
  String name;
  public void eat() {
    System.out.println("I can eat");
  }
}

// inherit from Animal
class Dog extends Animal {

  // new method in subclass
  public void display() {
    System.out.println("My name is " + name);
  }
}

class Main {
  public static void main(String[] args) {

    // create an object of the subclass
    Dog labrador = new Dog();

    // access field of superclass
    labrador.name = "Rohu";
    labrador.display();

    // call method of superclass
    // using object of subclass
    labrador.eat();

  }
}
\end{verbatim}

si ottiene il seguente albero:

\begin{verbatim}
(program
  (line_comment)
  (package_declaration
    (scoped_identifier scope: (identifier) name: (identifier)))
  (class_declaration
    name: (identifier)
    body: (class_body
      (line_comment)
      (field_declaration
        type: (type_identifier)
        declarator: (variable_declarator name: (identifier)))
      (method_declaration
        (modifiers)
        type: (void_type)
        name: (identifier)
        parameters: (formal_parameters)
        body: (block
          (expression_statement
            (method_invocation
              object: (field_access object: (identifier) field: (identifier))
              name: (identifier)
              arguments: (argument_list (string_literal))))))))
  (line_comment)
  (class_declaration
    name: (identifier)
    superclass: (superclass (type_identifier))
    body: (class_body
      (line_comment)
      (method_declaration
        (modifiers)
        type: (void_type)
        name: (identifier)
        parameters: (formal_parameters)
        body: (block
          (expression_statement
            (method_invocation
              object: (field_access object: (identifier) field: (identifier))
              name: (identifier)
              arguments: (argument_list
                (binary_expression
                  left: (string_literal)
                  right: (identifier)))))))))
  (class_declaration
    name: (identifier)
    body: (class_body
      (method_declaration
        (modifiers)
        type: (void_type)
        name: (identifier)
        parameters: (formal_parameters
          (formal_parameter
            type: (array_type element: (type_identifier) dimensions: (dimensions))
            name: (identifier)))
        body: (block
          (line_comment)
          (local_variable_declaration
            type: (type_identifier)
            declarator: (variable_declarator
              name: (identifier)
              value: (object_creation_expression type: (type_identifier) arguments: (argument_list))))
          (line_comment)
          (expression_statement
            (assignment_expression
              left: (field_access object: (identifier) field: (identifier))
              right: (string_literal)))
          (expression_statement
            (method_invocation
              object: (identifier)
              name: (identifier)
              arguments: (argument_list)))
          (line_comment)
          (line_comment)
          (expression_statement
            (method_invocation
              object: (identifier)
              name: (identifier)
              arguments: (argument_list))))))))
\end{verbatim}

Con l'apposita libreria $tree-sitter-stack-graphs$ e' possibile fare delle query all'albero in DSL per generare un grafo a partire dall'AST.

In generale un query e' specificata in questo modo:

\begin{verbatim}
(parent_tag (child_tag)@child_tag_node)@parent_tag_node
\end{verbatim}

Questa query matcha tutte le occorrenze di $parent\_tag$ ove e' presente un $child_tag$ come figlio. Si noti che questa query matcha una occorrenza di $parent\_tag$ una volta per ogni suo figlio di tipo $child_tag$. $@child_tag_node$ identifica il nodo dell'AST $child_tag$.

Ad ogni query e' possibile accompagnare un blocco di codice che specifica le operazioni da effettuare. Ogni istruzione e' indicata in formato $function arg0 arg1 ...$. In pratica lisp senza parentesi nel blocco principale! Richiamando l'esempio precendente:

\begin{verbatim}
(parent_tag (child_tag)@child_tag_node)@parent_tag_node {
  node the_node
  attr (the_node) property = "value"
}
\end{verbatim}

La funzione $node$ dichiara un nodo del grafo generato, mentre la funzione $attr$ aggiunge attributi dal nodo del grafo.

\paragraph{proprieta' di nodi e archi}

Ad ogni nodo e' possibile accompagnare il tipo $type$ che puo' assumere i seguenti valori:

\begin{itemize}
  \item "push\_symbol"
  \item "pop\_symbol"
\end{itemize}

Push e Pop sono le operazioni sul SymbolStack. Questo stack e' utilizzato durante la ricerca dei name binding di uno stack\_graph. In generale e' bene ricordare che una \textbf{push} deve essere associata ad un nodo di reference e una \textbf{pop} ad un nodo di definizione.

I nodi possono contenere anche informazioni "di debug", che nella pratica posso essere utilizzate per tenere traccia di tutta una serie di informazioni, come per esempio il tipo "semantico" di un nodo (classe, funzione ... etc) e anche per scopi di debug. Per assegnare il valore $varname$ ad un nodo si assegna con $attr$ l'attributo $debug\_varname$. Queste informazioni saranno accessibili da un programma che usa la libreria $stack-graphs$ (richiesta da $tree-sitter-stack-graphs$

\paragraph{funzioni particolari}

E' presente una funzione $source-text$ che dato un nodo AST restituisce la stringa che rappresenta quel nodo.
